\documentclass[tikz, letterpaper,12pt]{article}

\usepackage{geometry}
\usepackage{pslatex}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{color}
\usepackage{subcaption}
\usepackage{float}
\usepackage{tikz}
\usepackage{setspace}
\geometry{ margin = 1.0in }

\usetikzlibrary{matrix,backgrounds}
\usepackage{listings}
\usepackage{color}

\usepackage[fleqn]{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=1mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\usepackage{amssymb, amsthm, bm, nicefrac}

\newcommand{\xto}[1]{\xrightarrow{#1}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\left\|#1\right\|}
\newcommand{\normal}{\trianglelefteq}
\renewcommand{\qedsymbol}{\rule{0.7em}{0.7em}}

\newcommand{\aaa}[1]{\hspace{0.65cm}\parbox[t]{15.3cm}{#1}}
\newcommand{\aab}[1]{\hspace{1.15cm}\parbox[t]{15.0cm}{#1}}
\newcommand{\aac}[1]{\hspace{1.65cm}\parbox[t]{15.0cm}{#1}}
\newcommand{\aad}[1]{\hspace{2.15cm}\parbox[t]{15.0cm}{#1}}
\newcommand{\aae}[1]{\hspace{2.65cm}\parbox[t]{15.0cm}{#1}}
\newcommand{\aaf}[1]{\hspace{3.15cm}\parbox[t]{15.0cm}{#1}}
\newcommand{\aag}[1]{\hspace{3.65cm}\parbox[t]{15.0cm}{#1}}
\newcommand{\aaA}[2]{\hspace{0.5cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\aaB}[2]{\hspace{1.0cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\aaC}[2]{\hspace{1.5cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\aaD}[2]{\hspace{2.0cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\aaE}[2]{\hspace{2.5cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\aaF}[2]{\hspace{3.0cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\aaG}[2]{\hspace{3.5cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\xxx}{\par\vspace{0.1cm}}

%%% TODO modify these variables %%%
\def\homeworknum{5}
\def\namex{Param Somane}
\def\accessx{pss5256}
%%%%

\pagestyle{fancy}
\lhead{{\bf CMPSC 465 Fall 2020}}
\chead{{\bf Writing Assignment~\homeworknum}}
\rhead{{\bf November 29, 2020}}

\newcounter{problemid}\stepcounter{problemid}
\def\newproblem{\vspace*{0.01cm}{\bf Problem~\arabic{problemid}\stepcounter{problemid}}\hfill\fbox{\parbox{0.16\textwidth}{\bf Points:}}\par}

\setlength\parindent{0em}
\setlength\parskip{6pt}
\setlength{\fboxsep}{6pt}
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{claim}{Claim}
\newtheorem{fact}{Fact}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}

\makeatletter
\renewenvironment{proof}[1][\proofname]{\par
  \vspace{-\topsep}% remove the space after the theorem
  \pushQED{\qed}%
  \normalfont
  \topsep4pt \partopsep1pt % no space before
  \trivlist
  \item[\hskip\labelsep
        \itshape
    #1\@addpunct{.}]\ignorespaces
}{%
  \popQED\endtrivlist\@endpefalse
  \addvspace{6pt plus 6pt} % some space after
}
\makeatother

\begin{document}

\framebox[\textwidth]{
	\parbox{0.96\textwidth}{
		\parbox{0.08\textwidth}{\bf Name:}\parbox{0.65\textwidth}{\namex}\parbox{0.12\textwidth}{\bf Access ID:}\parbox{0.14\textwidth}{\accessx}
	}
}

%% your solutions %%%
\newproblem
1. Order of edges added to MST when Kruskal's algorithm is run on the graph:
\begin{enumerate}
  \item $(a,\,c)\;-\;2$
  \item $(a,\,b)\;-\;3$
  \item $(b,\,e)\;-\;3$
  \item $(c,\,f)\;-\;3$
  \item $(d,\,e)\;-\;4$
  \item $(f,\,g)\;-\;6$
\end{enumerate}

2. Order of vertices added to MST when Prim's algorithm is run on the graph:
\begin{enumerate}
  \item $a$
  \item $c$
  \item $b$
  \item $e$
  \item $f$
  \item $d$
  \item $g$
\end{enumerate}

\newproblem
Let $G=(V,E)$ be an undirected graph with edge weights $w(e)$ for all $e\in E$. Let $T=(V^{*}, E^{*})$ be the MST of $G$. Let $e'\in E$ be some edge. First, we assume that $G'=(V,E\setminus\{e'\})$ is connected, that is the graph resulting from the deletion of $e'$ from $G$ consists of a single connected component and thereby has a spanning tree. Depending on whether or not $e'\in E^{*}$, we consider the following two cases.

If $e'\notin E^*$, that is $e'$ is not in the MST, then the deletion of $e'$ from $G$ does not affect the MST of $G$ because $V^{*}=V$ and $|E^{*}|=|V|-1$ remain unaffected by the deletion. Thus, the MST of the resulting graph is $T$ itself.

If $e'\in E^{*}$, that is $e'$ is part of the MST of $G$, then the deletion of $e'$ from $G$, and thereby from $T$, splits $T$ into two disjoint, connected components (subtrees). 
As we have assumed that $G'$ is connected, there must be at least one edge $e''\in E\setminus\{e'\}$ that connects these two subtrees. The MST of $G'$ is then the union of these two subtrees with $e''$, where $e''$ is chosen such that $w(e'')$ is minimum among all viable candidate edges. 
The resulting tree $T'=(V^{*}', E^{*}')$, where $V^{*}'=V$ and $E^{*}'=(E^{*}\setminus\{e'\})\cup\{e''\}$ is the MST of $G'$ because it is connected by construction, $|E^{*}'|=|E^{*}|-1+1=|V|-1$, and $\sum_{e\in E^{*}'}w(e)=\sum_{e\in E^{*}}w(e)-w(e')+w(e'')$ is minimized. 
Note that this follows from the cut property of minimum spanning trees as $E^{*}\setminus\{e'\}$ is a partial MST of $G$ and consequently, $E^{*}'$ must be an MST of $G'$ as $E^{*}'\subseteq E\setminus\{e'\}$.

\textbf{Running time:} Checking whether or not $e'\in E^{*}$ takes $O(|E^{*}|)=O(|V|)$ time and in the case that $e'\in E^{*}$, searching for the required $e''$ with minimum possible weight takes $O(|E|)$ times as we need to cycle through all the edges in $E\setminus E^{*}$. Since $|V|<|E|$, the algorithm runs in $O(|E|)$ time.

\newproblem
Let $G=(V,E)$ be an undirected graph with distinct edge weights $w(e)$ for each $e\in E$.

1. Let $C$ be a cycle of $G$ and $e^{*}:=arg\;\max_{e\in C}w(e)$ be the edge with the largest weight in $C$.
\begin{proof}Suppose, toward a contradiction, that $e^{*}=(u,v)$ appears in a minimum spanning tree $T=(V^{*},E^{*})$ of $G$. Now, if we omit $e^{*}$ from $G$, then we will split $T$ into two disjoint subtrees because $e^{*}\in E^{*}$ by assumption. Since $C$ is a cycle, there exists an alternative path from $u$ to $v$ that does not pass through $e^{*}$. In particular, there exists an edge $e'\in C$ that connects the above two subtrees and yields $T'=(V^{*},(E^{*}\setminus\{e^{*}\})\cup\{e'\}=:E^{*}')$ as another spanning tree of $G$ because $V^{*}=V$, $|E^{*}'|=|E^{*}|-1+1=|V|-1$, and it is connected. Moreover, $\sum_{e\in E^{*}'}w(e)=\sum_{e\in E^{*}}w(e)-w(e^*)+w(e')<\sum_{e\in E^{*}}w(e)$ because $w(e')<w(e^*)$ by the maximality of the weight of $e^{*}$ in $C$ and the distinctness of weights yields a strict inequality. This contradicts the minimality of $T$ as an MST of $G$. Ergo, $e^{*}$ cannot appear in any minimum spanning tree of $G$.
\end{proof}

2. It is assumed that $G$ is connected and so has an MST. Suppose that $G$ satisfies $|E|=|V|+9$. Recall that if $T=(V^{*},E^{*})$ is an MST of $G$, then $V^{*}=V$ and $|E^{*}|=|V|-1$. This implies that we need to remove $(|V|+9)-(|V|-1)=10$ suitable edges from $E$ to obtain $E^{*}$. Observe that we must have a cycle in $G$ because $|E|\neq |V|-1$ and $G$ is connected. Subsequently, we run the DFS algorithm on $G$ to find the first occurrence of a cycle by detecting presence of a back-edge and we alsom keep track of the edge in that cycle with the maximum weight. We delete this edge from $E$. This process is then repeated ten times and during each iteration, we are guaranteed to detect a cycle in the current graph because it has more edges than $|V|-1$. At the end of this process, we are left with a subgraph $T=(V^{*},E^{*})$ of $G$ that is connected, has $|V|-1$ edges, and spans all the $V$ vertices of $G$. Thus, $T$ must be a spanning tree of $G$. Observe that the edges with the maximum weight in any cycle of $G$ cannot appear in $T$ by 3 (1) and we have ommitted precisely these edges from $T$ by construction. Therefore, $\sum_{e\in E^{*}}w(e)$ is minimal and so $T$ is a minimum spanning tree of $G$.

\textbf{Running time:} Accounting for all the ten iterations, the total running time of the algorithm is 
\begin{align*}
    &O(|V|+|E|)+O(|V|+|E|-1)+\cdots+O(|V|+|E|-9)=O(10\cdot|V|+10\cdot|E|-45)\\
    &=O(20\cdot|V|+45)=O(|V|).
\end{align*}\newpage
\newproblem
Let $A[1\cdots n]$ be an array of $n$ intervals, where $A[i]=[L_i,R_i]$ for each $1\leq i\leq n$. The idea is to first sort the intervals in increasing order of $L_i$. Then the left endpoint of the last interval, $L_n\geq L_i$ for all $i$ and so we may choose $L_n$ to be in $S$. We examine the intervals in reverse order (descending order of $L_i$) and skip any intervals which contain $L_n$. At the first occurrence of an interval $A[k]$ which does not contain $L_n$, we include $L_k$ in $S$ because $A[k]$ is disjoint from $[L_n,R_n]$ as $R_k<L_n$. This process is repeated until all the $n$ intervals have been examined and the resulting set $S$ contains exactly one integer inside every interval $A[i]$; thus, $|S|$ is minimal as required. The pseudocode below illustrates this idea.

\begin{minipage}{0.8\textwidth}
	\aaA {11}{Algorithm INTERVAL-GREEDY~($A[1\cdots n]$)}\xxx
	\aab {sort $A$ in increasing order of $L_i$;}\xxx
	\aab {init $j=n$; //keep track of previously added interval}\xxx
	\aab {init $S=\{L_n\}$;}\xxx
	\aaB {5}{for $i=n-1\to 1$}\xxx
	\aaC {3}{if $R_i<L_j$ //last element of $S$ $\notin$ $A[i]$}\xxx
	\aad {$S.add(L_i)$;}\xxx
	\aad {set $j=i$;}\xxx
	\aac {end if;}\xxx
	\aab {end for;}\xxx
	\aab {report $|S|$ as the least possible size of $S$;}\xxx
	\aaa {end algorithm;}\xxx
\end{minipage}

\textbf{Running time:} The running time of the algorithm is dominated by the sorting of intervals according to the left endpoints because the for-loop runs in linear time; thus, the running time of the algorithm is $O(n\,log\,n)$.

\newproblem
Let the list of $n$ items $L=\{p_1,\cdots,p_n\}$ with distinct importance rates $w_I\geq 0$ be given. Let $C[1\cdots n]$ be the list of optimal costs that sum up to the minimized total money required to buy all the items subject to the stated two constraints. Observe that for any given $1\leq i\leq n$, whenever valid, we have that $w_{i-1}<w_i\implies C[i-1]<C[i]$ and $w_i>w_{i+1}\implies C[i]>C[i+1]$. Thus, we first traverse the rates $w_i$ in the forward direction and mark the costs for the sequences of increasing rates, while neglecting any decreasing sequence. Next, we traverse the rates in the reverse direction and mark the costs for sequences of decreasing rates, while neglecting any increasing sequence (with respect to the forward direction). Lastly, we take the maximum of the increasing and decreasing costs as the final cost for each item. The resulting array of costs preserves both the increasing as well as the decreasing order of importance rates while assigning costs as both of the above inequalities hold true for all $i$.

The greedy portion of the algorithm lies in setting to 1 (the lowest possible cost) any decreasing sequence with respect to either direction of traversal. Hence, the resulting array of costs sums up to the minimized total money needed to be spent because if it did not, then one of the $C[i]$'s would need to take on a lower value than its assigned value to lower the total sum and subsequently, its cost would not satisfy the second required condition with respect to its adjacent neighbors. The algorithm below portrays this idea.

\begin{minipage}{0.8\textwidth}
	\aaA {16.5}{Algorithm GREEDY-ITEMS~($\forall 1\leq i\leq n,\,w_i\geq 0$ distinct importance rates)}\xxx
	\aab {init $C[1\cdots n]$;}\xxx
	\aab {init $incC[1\cdots n]$;}\xxx
	\aab {init $decC[1\cdots n]$;}\xxx
	\aab {set $incC[1]=1,\;decC[n]=1;$}\xxx
	\aaB {3}{for $i=2\to n$}\xxx
	\aac {if $w_{i-1}<w_i$: $incC[i]=incC[i-1]+1$;}\xxx
	\aac {else: $incC[i]=1$;}\xxx
	\aab {end for;}\xxx
	\aaB {3}{for $i=n-1\to 1$}\xxx
	\aac {if $w_{i+1}<w_i$: $decC[i]=decC[i+1]+1$;}\xxx
	\aac {else: $decC[i]=1$;}\xxx
	\aab {end for;}\xxx
	\aaB {2}{for $i=1\to n$}\xxx
	\aac {$C[i]=\max\{incC[i],\,decC[i]\}$;}\xxx
	\aab {end for;}\xxx
	\aab {report $sum(C)$ as the minimized total money for buying all items;}\xxx
	\aaa {end algorithm;}\xxx
\end{minipage}

\textbf{Running time:} The algorithm implements three for-loops, each of which runs in linear time. Thus, the algorithm runs in $O(n)$ time.

\textbf{Bonus Problem}

We wish to find an order $I$ of jobs which minimizes $\sum_{i=1}^n s_i\cdot f_i=:\xi(I)$. For this purpose, we sort the $n$ jobs in descending order of significance to processing time ratio $s_i/t_i$ because this permits us to isolate jobs with a greater significance per unit time and assign them to be earlier in the order; also, this greedy strategy works in the proof provided below. We claim that this sorted order minimizes $\sum_{i=1}^n s_i\cdot f_i$.

\textbf{Running time:} Sorting by $s_i/t_i$ takes $O(n\,log\,n)$ time, which dominates in the algorithm. 

\textbf{Correctness:} Let $I=\{i_1,i_2,\cdots,i_n\}$ be an optimal order of jobs (sorted in descending order of ratios as mentioned above) and suppose that job $j$ is immediately before job $i$ in $I$. Hence, $s_j/t_j\geq s_i/t_i$. Let $J$ be another order of jobs obtained by swapping positions of jobs $i$ and $j$ in $I$. Let $T$ be the sum of processing times of all jobs prior to job $j$ in the order $I$. Observe that
\begin{align*}
    \xi(J)-\xi(I)&=(s_i(T+t_i)+s_j(T+t_i+t_j))-(s_j(T+t_j)+s_i(T+t_j+t_i))\\
    &=s_jt_i-s_it_j=t_it_j\left(\frac{s_j}{t_j}-\frac{s_i}{t_i}\right)\\
    &\geq 0\quad (\because j\text{ is before }i\text{ in descending order }I)
\end{align*}
Ergo, $\xi(I)\leq \xi(J)$, that is the sum of products of significance and finishing-time of jobs in $J$ is at least as much as that of the jobs in $I$; hence it is not possible that $I$ is not an optimal order of jobs that minimizes $\sum_{i=1}^n s_i\cdot f_i$.

\end{document}